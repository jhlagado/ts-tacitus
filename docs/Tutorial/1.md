Sure! Here's the content of 01_introduction.md as a code block for easy copying:

# Chapter 1 – Introduction and Philosophy

Tacit is a modern, dynamically typed, stack‑based language designed for
concise and expressive programs.  Its execution model builds on the
Reverse Polish Notation (RPN) tradition but extends it with
first‑class list structures, a unified type system and a well defined
virtual machine.  This chapter introduces the guiding philosophy
behind Tacit and sets the stage for the rest of the tutorial.

## 1.1 Why Tacit?

Stack‑based languages have a long history because they offer simple
syntax and predictable execution.  In RPN languages there is no need
for parentheses to control order of evaluation; instead, values are
pushed on to a stack and operations consume their operands from the
top of the stack.  Tacit embraces this foundation but also addresses
some of the limitations of earlier RPN languages by providing
high‑level constructs, dynamic types and powerful data structures.

Tacit programs are composed of **values**, **lists**, **variables** and
**operations**.  All values live in a uniform 32‑bit cell and are
identified by a tag that describes their type.  Lists provide
structured data without resorting to pointers or heap allocations:
they live on the stack and can nest arbitrarily.  Variables give
names to values so that you do not have to manually manipulate the
stack for every operation.

Tacit is intentionally *specification‑driven*.  The behaviour of each
data type, operation and control flow construct is described in detail
in the project’s specifications.  This tutorial builds on those
specifications to teach Tacit from a programmer’s perspective.

## 1.2 Stack‑Based Execution at a Glance

Tacit executes code immediately as it is encountered.  For example, the
phrase `1 2 +` pushes the numbers 1 and 2 on to the stack and then
applies the addition builtin, leaving `3` on the stack.  There is no
implicit collection of arguments or operator precedence: everything
happens in a strict left‑to‑right order with fixed arity operations.
Throughout this tutorial you will see stack diagrams and code blocks
that illustrate how values move on the stack as operations are
performed.

One of Tacit’s core strengths is that it can express complex
computation without naming every intermediate value.  At the same
time, the language provides **local** and **global variables** to hold
important values, making programs easier to read and maintain.  Lists
and references allow you to work with structured data at a higher
level than individual stack cells.

## 1.3 Segments and Memory

Tacit’s virtual machine uses **segmented memory**.  There are four
segments: the **data stack** (`STACK`), the **return stack**
(`RSTACK`), the **code segment** (`CODE`) and the **string segment**
(`STRING`).  Each segment stores 32‑bit cells.  The data stack holds
operands and values; the return stack holds function call frames and
local variables; the code segment contains bytecode to execute; and
the string segment stores string literals.

Values in Tacit are represented using a *NaN‑boxed encoding*.  This
means that each 32‑bit cell stores a quiet NaN bit pattern and uses
some bits to store a **tag** identifying the kind of value (number,
string, list, builtin, code reference, sentinel) and other bits to
store a small payload.  The details of the encoding are covered later
in this tutorial, but it is helpful to understand from the outset
that all values share a common representation.

## 1.4 Design Goals and Features

Tacit is designed with the following goals in mind:

* **Simplicity of syntax** – the core language has minimal syntax.
  Operations are space‑separated tokens executed in order.

* **Dynamic typing** – unlike many RPN languages that operate on
  homogeneous stack values, Tacit supports numbers, strings, lists,
  code references and more as first‑class types.  The VM enforces
  type safety at runtime.

* **First‑class lists** – lists are contiguous structures on the
  stack.  They support O(1) prepend/drop operations, nested lists,
  bracket notation for element access and in‑place mutation where
  appropriate.

* **Names and scope** – variables can be declared locally inside
  functions or globally at the module level.  Named values make code
  easier to read and manage.

* **Specification‑driven** – each aspect of the language is described
  in normative specifications.  The VM implementation and this
  tutorial follow those specifications.

By the end of this tutorial you will be able to read and write Tacit
programs that leverage these features.  In the next chapter you will
learn how to set up your environment and run Tacit code.

Feel free to copy and paste this into your editor. When you're ready for the next file, just let me know!

