/**
 * @file src/lang/interpreter.ts
 *
 * This file implements the interpreter for the Tacit language.
 *
 * The interpreter is responsible for executing bytecode generated by the parser.
 * It handles the main execution loop, opcode dispatch, error handling, and function calls.
 * The interpreter maintains the VM state during execution, including the instruction
 * pointer, stack, and return stack.
 *
 * The interpreter provides three main entry points:
 * - execute: Runs bytecode starting from a specific address
 * - executeProgram: Parses and executes a string of Tacit code
 * - callTacit: Calls a Tacit function and returns to the caller
 */

import { executeOp } from '../ops/builtins';
import { parse } from './parser';
import { toTaggedValue, Tag, SEG_CODE, RSTACK_BASE_CELLS } from '@src/core';
import { Tokenizer } from './tokenizer';
import { nextOpcode, getStackData, rpush } from '../core/vm';
import type { VM } from '../core/vm';

// SEG_CODE imported from @src/core

/**
 * Executes Tacit bytecode starting from a specific address.
 *
 * This function implements the main execution loop of the Tacit VM. It:
 * 1. Sets the instruction pointer to the start address
 * 2. Fetches and executes opcodes in a loop until execution is halted
 * 3. Handles errors during execution with detailed diagnostics
 * 4. Resets the compiler state after execution
 *
 * The execution can be configured to break when reaching a specific instruction
 * address, which is useful for debugging and implementing breakpoints.
 *
 * @param {VM} vm - The VM instance to execute on
 * @param {number} start - The starting address (instruction pointer) for execution
 * @param {number} [breakAtIP] - Optional address at which to halt execution
 * @throws {Error} If an invalid opcode is encountered or execution fails
 */
export function execute(vm: VM, start: number): void {
  vm.IP = start;
  vm.running = true;

  while (vm.running && vm.IP < vm.compiler.CP) {
    const firstByte = vm.memory.read8(SEG_CODE, vm.IP);
    const isUserDefined = (firstByte & 0x80) !== 0;

    const functionIndex = nextOpcode(vm);

    if (vm.debug) {
// eslint-disable-next-line no-console
console.log({ functionIndex, isUserDefined }, vm.IP - (isUserDefined ? 2 : 1));
}

    try {
      if (functionIndex < 0 || functionIndex >= 32768) {
        const originalIP = vm.IP - (isUserDefined ? 2 : 1);
        const rawValue = vm.memory.read8(SEG_CODE, originalIP);
        throw new Error(`Invalid opcode: ${rawValue}`);
      }

      executeOp(vm, functionIndex, isUserDefined);
    } catch (error) {
      const stackState = JSON.stringify(getStackData(vm));
      const errorMessage =
        `Error executing word (stack: ${stackState})${
        error instanceof Error ? `: ${error.message}` : ''}`;
      if (vm.debug) {
// eslint-disable-next-line no-console
console.log((error as Error).stack);
}
      vm.compiler.reset();
      vm.compiler.preserve = false;
      throw new Error(errorMessage);
    }
  }

  vm.compiler.reset();
  vm.compiler.preserve = false;
}

/**
 * Parses and executes a string of Tacit code.
 *
 * This function provides a high-level entry point for running Tacit programs.
 * It tokenizes and parses the input code, then executes the resulting bytecode.
 *
 * @param {VM} vm - The VM instance to use
 * @param {string} code - The Tacit source code to execute
 */
export function executeProgram(vm: VM, code: string): void {
  parse(vm, new Tokenizer(code));
  execute(vm, vm.compiler.BCP);
}

/**
 * Executes a specific block of Tacit code using the current global VM state.
 *
 * This function allows calling a Tacit function from JavaScript code. It:
 * 1. Saves the current execution context (IP and BP) on the return stack
 * 2. Sets up a new execution context for the called function
 * 3. Executes the function until it returns via an 'exit' operation
 * 4. Restores the original execution context
 *
 * Unlike executeProgram, this function does not reset the interpreter state,
 * allowing it to be used within an ongoing execution. This is particularly
 * useful for implementing foreign function interfaces and for the re-entrant
 * execution of resumable functions.
 *
 * @param {number} codePtr - The starting address (instruction pointer) of the Tacit code to execute
 */
export function callTacit(codePtr: number): void {
  const returnIP = vm.IP;
  // Step 1.2 (adjusted): Use conditional prologue matching callOp/exitOp until
  // Frame migration complete: BP is cell-based and unified.
  // compatibility for code/tests still expecting byte-based BP frames.
  rpush(vm, toTaggedValue(returnIP, Tag.CODE));
  // Unified cell-only frame prologue: save BP as relative cells
  rpush(vm, vm.bp - RSTACK_BASE_CELLS);
  vm.bp = vm.rsp;

  vm.IP = codePtr;
  vm.running = true;
  execute(vm, vm.IP);

  if (vm.IP !== returnIP) {
    if (vm.debug) {
      console.warn(`Warning: IP mismatch after function call. Expected ${returnIP}, got ${vm.IP}`);
    }
    vm.IP = returnIP;
  }
}

// Style alias (Phase 1):
// old alias removed
