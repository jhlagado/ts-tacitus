# TACIT Bytecode System Architecture

## Overview

The TACIT language uses a sophisticated bytecode virtual machine with a unified addressing scheme and stack-based execution model. This document explains how the bytecode system works, how colon definitions are encoded, and the execution flow.

## Unified Addressing Scheme

TACIT uses a clever unified addressing scheme that handles both built-in operations and user-defined words in a single namespace:

- **Built-in opcodes (0-127)**: Encoded as single bytes
- **User-defined words (128-32767)**: Encoded as two bytes with little-endian format

### Opcode Encoding

The encoding logic in `vm.nextOpcode()` reads the first byte:
- If MSB is clear (< 128): It's a single-byte built-in opcode
- If MSB is set (â‰¥ 128): Read second byte and combine: `((secondByte << 7) | (firstByte & 0x7f))`

```typescript
nextOpcode(): number {
  const firstByte = this.memory.read8(SEG_CODE, this.IP);
  this.IP += 1;
  if ((firstByte & 0x80) !== 0) {
    const secondByte = this.memory.read8(SEG_CODE, this.IP);
    this.IP += 1;
    const lowBits = firstByte & 0x7f;
    const highBits = secondByte << 7;
    return highBits | lowBits;
  }
  return firstByte;
}
```

### Address Space Layout

| Range      | Type           | Encoding        | Example |
|------------|----------------|-----------------|---------|
| 0-127      | Built-in ops   | Single byte     | `[32]` = Dup |
| 128-32767  | User words     | Two bytes LE    | `[80][01]` = word 128 |

## Bytecode Execution Loop

The main interpreter loop (`execute()`) follows a classic fetch-decode-execute cycle:

1. **Fetch**: `vm.nextOpcode()` reads and decodes the next instruction
2. **Dispatch**: `executeOp(vm, functionIndex)` routes to the appropriate handler
3. **Execute**: Either a built-in operation or user-defined word executes
4. **Repeat**: Continue until `vm.running` becomes false

```typescript
export function execute(start: number, breakAtIP?: number): void {
  vm.IP = start;
  vm.running = true;

  while (vm.running) {
    if (breakAtIP !== undefined && vm.IP === breakAtIP) {
      vm.running = false;
      break;
    }

    const functionIndex = vm.nextOpcode();
    
    try {
      if (functionIndex < 0 || functionIndex >= 32768) {
        throw new Error(`Invalid opcode: ${functionIndex}`);
      }
      executeOp(vm, functionIndex);
    } catch (error) {
      // Error handling...
    }
  }
}
```

## Colon Definition Compilation

When the parser encounters a colon definition like `: square dup * ;`, the compilation process involves three phases:

### 1. Begin Definition (`beginDefinition()`)

Creates a branch instruction to skip over the definition during normal execution:

```typescript
// Create skip instruction
const branchPos = vm.compiler.CP;
vm.compiler.compileOpcode(Op.Branch);  // Skip instruction  
vm.compiler.compile16(0);              // Placeholder offset (patched later)

// Register the word in symbol table
const wordAddress = vm.compiler.CP;    // Current position = word body start
vm.symbolTable.define(name, wordAddress);
```

### 2. Compile Word Body

The parser compiles each token in the word body:
- **Numbers**: Become `LiteralNumber` opcodes followed by 4-byte float values
- **Words**: Become their opcode addresses (single or double byte encoding)
- **Strings**: Become `LiteralString` opcodes with string table references
- **Code blocks**: Become `LiteralCode` opcodes with tagged addresses

### 3. End Definition (`endDefinition()`)

Finalizes the word definition:

```typescript
vm.compiler.compileOpcode(Op.Exit);    // Word returns here
patchBranchOffset(branchPos);          // Patch the skip offset
```

The `patchBranchOffset()` calculates: `endAddress - (branchPos + 2)` and patches it into the bytecode.

## Bytecode Layout Example

For the definition `: square dup * ;`, the generated bytecode looks like:

```
Address  Bytecode    Instruction      Meaning
0x100    [02]        Branch           Skip over definition
0x101    [06][00]    Offset +6        Jump to 0x109
0x103    [32]        Dup              Duplicate top of stack
0x104    [21]        Multiply         Multiply top two values  
0x105    [05]        Exit             Return to caller
0x106    ...         (next code)      Execution continues here
```

### Execution Flow

1. **Normal execution**: When the interpreter reaches 0x100, the Branch instruction skips to 0x109
2. **Word call**: When `square` is invoked, execution jumps directly to 0x103
3. **Word execution**: Executes `dup`, `*`, then `exit` returns to caller

## Function Call Mechanism

TACIT uses a sophisticated call/return mechanism with stack frame management:

### Call Setup (`callOp`)

When a colon definition is called:

1. Push return address (current IP) onto return stack as tagged CODE value
2. Push current base pointer (BP) onto return stack
3. Set new BP = RP (return stack pointer) - establishes new stack frame
4. Jump to word address (set IP = target address)

```typescript
export const callOp: Verb = (vm: VM) => {
  const callAddress = vm.next16();
  vm.rpush(toTaggedValue(vm.IP, Tag.CODE));  // Save return address
  vm.rpush(vm.BP);                           // Save base pointer
  vm.BP = vm.RP;                             // New stack frame
  vm.IP = callAddress;                       // Jump to function
};
```

### Return Handling (`exitOp`)

When a word finishes execution:

1. Restore BP from return stack
2. Pop return address from return stack  
3. Jump back to return address
4. If return stack is empty, stop VM execution

```typescript
export const exitOp: Verb = (vm: VM) => {
  if (vm.RP < 2 * BYTES_PER_ELEMENT) {
    vm.running = false;  // Main program exit
    return;
  }

  vm.BP = vm.rpop();                        // Restore base pointer
  const returnAddr = vm.rpop();             // Get return address
  
  if (isCode(returnAddr)) {
    const { value: returnIP } = fromTaggedValue(returnAddr);
    vm.IP = returnIP;                       // Jump back
  }
};
```

## Stack Frame Architecture

TACIT maintains two stacks:

### Data Stack
- Holds computational values during execution
- Managed by SP (Stack Pointer)
- Used for parameters and intermediate results

### Return Stack  
- Holds return addresses and base pointers
- Managed by RP (Return Stack Pointer)
- Used for function call frames and local variables

### Stack Frame Layout

```
Return Stack:
  [BP_n]     <- Previous base pointer
  [ADDR_n]   <- Return address (tagged CODE)
  [BP_n-1]   <- Caller's base pointer  
  [ADDR_n-1] <- Caller's return address
  ...
  
BP -> [Current frame base]
RP -> [Next free position]
```

## Key Design Features

### Branch-and-Patch Compilation

Forward references use placeholder offsets that get patched when the target is known:

```typescript
function patchBranchOffset(branchPos: number): void {
  const endAddress = vm.compiler.CP;
  const branchOffset = endAddress - (branchPos + 2);
  
  // Temporarily set CP to patch location
  const prevCP = vm.compiler.CP;
  vm.compiler.CP = branchPos;
  vm.compiler.compile16(branchOffset);
  vm.compiler.CP = prevCP;
}
```

### Unified Dispatch

Single `executeOp()` function handles both built-ins and user words:

```typescript
export function executeOp(vm: VM, opcode: Op) {
  switch (opcode) {
    case Op.LiteralNumber:
      literalNumberOp(vm);
      break;
    case Op.Add:
      addOp(vm);
      break;
    // ... built-in operations
    default:
      if (opcode >= 128 && opcode < 32768) {
        // User-defined word - look up in function table
        const implementation = vm.symbolTable.findImplementationByOpcode(opcode);
        if (implementation) {
          implementation(vm);
          return;
        }
      }
      throw new InvalidOpcodeError(opcode);
  }
}
```

### Efficient Encoding

Variable-length opcodes save memory:
- 1 byte for frequently-used built-ins (0-127)
- 2 bytes for user words (128-32767)
- Total address space: 32,768 operations

## Opcode Categories

### Control Flow Operations
- `LiteralNumber`: Push numeric literal onto stack
- `Branch`: Unconditional jump (used for definition skipping)
- `BranchCall`: Conditional jump (used for code blocks)
- `Call`: Function call with stack frame setup
- `Exit`: Return from function
- `Eval`: Execute code pointer from stack

### Stack Operations
- `Dup`: Duplicate top of stack
- `Drop`: Remove top of stack
- `Swap`: Exchange top two stack items
- `Rot`: Rotate top three stack items

### Arithmetic Operations
- `Add`, `Subtract`, `Multiply`, `Divide`
- `Power`, `Mod`, `Abs`, `Neg`
- Mathematical functions: `Sqrt`, `Exp`, `Ln`, `Log`

### Comparison Operations
- `Equal`, `LessThan`, `GreaterThan`
- `LessOrEqual`, `GreaterOrEqual`

### List Operations
- `OpenList`: Begin list construction
- `CloseList`: Finalize list construction
- `mEnlist`: Convert scalar to single-element list

## Memory Segments

TACIT uses a segmented memory model:

- **SEG_CODE**: Bytecode storage (executable)
- **SEG_STACK**: Data stack (read/write)
- **SEG_RSTACK**: Return stack (read/write)
- **SEG_DATA**: Static data storage

## Tagged Value System

TACIT uses NaN-boxing for efficient value representation:

- **Numbers**: IEEE 754 finite values stored directly
- **Tagged values**: Use NaN space for type information
  - `Tag.CODE`: Code pointers (executable addresses)
  - `Tag.STRING`: String table references
  - `Tag.LIST`: List headers with size information

## Performance Characteristics

### Advantages
- **Compact bytecode**: Variable-length encoding saves memory
- **Fast dispatch**: Direct function pointer lookup
- **Efficient calls**: Minimal stack frame overhead
- **Type safety**: Tagged values prevent type confusion

### Trade-offs
- **Two-byte overhead**: User words require extra byte
- **Patch complexity**: Forward references need two-pass compilation
- **Stack overhead**: Return stack manages call frames

## Debugging Support

The VM provides debugging capabilities:

```typescript
if (vm.debug) {
  console.log({ functionIndex }, vm.IP - (functionIndex >= 128 ? 2 : 1));
}
```

This logs each executed instruction with its address, enabling step-through debugging.

## Conclusion

The TACIT bytecode system demonstrates several sophisticated VM design principles:

1. **Unified addressing** seamlessly integrates built-ins with user definitions
2. **Stack-based execution** provides clean, composable semantics  
3. **Efficient encoding** balances space usage with execution speed
4. **Robust call/return** supports complex control flow patterns

This architecture allows TACIT to seamlessly mix built-in operations with user-defined words in a single, efficient bytecode stream. The colon definitions become callable functions that integrate naturally with the stack-based execution model, providing both performance and expressiveness.
